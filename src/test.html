<!DOCTYPE html>
<html>
<!-- UTIL FILES FOR SYSTEM FUNCTION -->
<script type="text/javascript" src="../utils/webgl-utils.js"></script>
<script type="text/javascript" src="../utils/initShaders.js"></script>
<script type="text/javascript" src="../math/MV.js"></script>
<script type="text/javascript" src="../math/Mat4.js"></script>
<script type="text/javascript" src="plane.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="primitives.js"></script>
<script type="text/javascript" src="particleStream.js"></script>
<script type="text/javascript" src="particle.js"></script>
<script type="text/javascript" src="wall.js"></script>

<head>
<title>Project LINK</title>
</head>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec3 coordinates;
attribute vec3 a_normal;
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
varying vec3 v_normal;

void main(){
vec4 position = vec4(u_projection * u_view * u_model * vec4(coordinates, 1.0));
gl_Position = position;
gl_PointSize = 10.0;
v_normal = a_normal;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
varying vec3 v_normal;

uniform vec4 u_color;
uniform vec3 u_reverseLightDirection;

void main(){
  // because v_normal is a varying it's interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

  float light = dot(normal, u_reverseLightDirection);

  gl_FragColor = u_color;
  // Lets multiply just the color portion (not the alpha)
  // by the light
  gl_FragColor.rgb *= light;
}
</script>
<style>
.slider {
  -webkit-appearance: none;
  width: 25%;
  height: 15px;
  border-radius: 5px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
}
</style>

<body bgcolor="#afafaf">
  <div>
    <canvas id="gl-canvas" width="1024" height="784">
      Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
  </div>
  <div class="slidecontainer">
    <input type="range" min="1" max="20" value="5" class="slider" id="speedValue">
    <label for="speedValue">Speed</label>
    <input type="range" min="1" max="100" value="5" class="slider" id="rhoDensity">
    <label for="rhoValue">rho</label>
  </div>

  <script>
    var gl;
    var u_color;
    var ground;
    var u_model, u_view, u_projection;
    var canvas;
    var now;
    var vertex_buffer, color_buffer, line_buffer, line_color_buffer;
    var program;
    var dragging;
    var oldx, x, oldy, y;
    var front = vec3(0.0, 0.0, -1.0);
    var box;
    var prevX, prevY = 0;
    var pitch = 0.0;
    var yaw = -90.0;
    var xpos = 0.0;
    var ypos = 1.0;
    var zpos = 1.0;
    var dx= 0, dy = 0;
    var forwardX = 0;
    var forwardZ = 0;
    var bobs = 0.2;
    var vBufferId, indexBuffer;
    var keyState = {};
    var cube;
    var slider, sliderRho, mousexNDC, mouseyNDC;
    var at = vec3(0.0, 0.0, -1.0);
    var eye = vec3(0.0, 0.2, 1.0);
    /*================Creating a canvas=================*/
    window.onload = function init(event){
      canvas = document.getElementById("gl-canvas"); //get the canvas instance
      slider = document.getElementById("speedValue");
      sliderRho = document.getElementById("rhoDensity");
      gl = WebGLUtils.setupWebGL(canvas); //setup the instance
      if ( !gl ) { alert( "WebGL isn't available" ); }

      box = gl.canvas.getBoundingClientRect();
      gl.viewport( 0, 0, canvas.width, canvas.height ); //set the instance view
      gl.clearColor( 0.5, 0.5, 0.5, 1.0 ); //set clear color of canvas
      gl.enable(gl.DEPTH_TEST);

      /*==========Defining and storing the geometry=======*/
      // ground = new Plane(100.0, 100.0, 0.0);
      // particle = new ParticleStream(0.0, 0.9, 10, 1000)
      camera = new Camera("fps")
      // wall = new Wall([-1, 0, -1], [1, 1, -1]);
      // cube = new Cube(0.10);

      program = initShaders(gl, "vertex-shader", "fragment-shader");
      gl.useProgram(program);

      cube = new Cube(0.2);

      //get uniform location for vertex shader
      u_model = gl.getUniformLocation(program, "u_model");
      u_projection = gl.getUniformLocation(program, "u_projection");
      u_view = gl.getUniformLocation(program, "u_view");
      u_color = gl.getUniformLocation(program, "u_color");

      // Create an empty buffer object to store the vertex buffer
      //Bind appropriate array buffer to it
      // Pass the vertex data to the buffer
      // Unbind the buffer
      //ground
      // gl.bindBuffer(gl.ARRAY_BUFFER, ground.vertexBuffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.grid.vertices), gl.STATIC_DRAW);
      // gl.bindBuffer(gl.ARRAY_BUFFER, null);

      //particle
      // particle_buffer = gl.createBuffer();
      // gl.bindBuffer(gl.ARRAY_BUFFER, particle_buffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particle.particleStreamVerts), gl.STATIC_DRAW);
      // gl.bindBuffer(gl.ARRAY_BUFFER, null);

      //wall
      // gl.bindBuffer(gl.ARRAY_BUFFER, wall.vertexBuffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(wall.values.vertices), gl.STATIC_DRAW);
      // gl.bindBuffer(gl.ARRAY_BUFFER, null);



      window.onmousemove = function(event){
        var mousex = event.clientX;
        var mousey = event.clientY;
        mousexNDC = (mousex / canvas.clientWidth) * 2 - 1;
        mouseyNDC = (1 - (mousey / canvas.clientHeight)) * 2 - 1;
      }

      /*============= Drawing the primitive ===============*/
      var now = 0;
      render()
    }

    function render(now, event){
      now = 0.01;
      // Clear the canvas AND the depth buffer.
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      tick();

      // // Turn on culling. By default backfacing triangles
      // // will be culled.
      // gl.enable(gl.CULL_FACE);

      // // Enable the depth buffer
      gl.enable(gl.DEPTH_TEST);
      lookat = lookAt(eye, vec3(eye[0] + at[0], eye[1] + (-at[1]), eye[2] + at[2]), vec3(0.0, 1.0, 0.0));

      //****************************************************************
      //for orbital
      // lookat = lookAt(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
      // let yrotate = rotate(yaw, 0.0, 1.0, 0.0);
      // let xrotate = rotate(pitch, 1.0, 0.0, 0.0);
      // lookat = mult(lookat, xrotate);
      // lookat = mult(lookat, yrotate);

      // gl.uniformMatrix4fv(u_model, false, flatten(mat4()));
      gl.uniformMatrix4fv(u_projection, false, flatten(perspective(90, canvas.height/canvas.width, 0.01, 1000)));
      gl.uniformMatrix4fv(u_view, false, flatten(lookat));
      // gl.uniform4fv(u_color, flatten(ground.grid.color));

      /*======== Associating shaders to buffer objects ========*/
      // Bind vertex buffer object
      // Get the attribute location
      // Point an attribute to the currently bound VBO
      // Enable the attribute
      //ground
      // gl.bindBuffer(gl.ARRAY_BUFFER, ground.vertexBuffer);
      // var coord = gl.getAttribLocation(program, "coordinates");
      // gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(coord);
      // gl.drawArrays(gl.LINES, 0, ground.grid.gridLines);
      //wall
      // gl.bindBuffer(gl.ARRAY_BUFFER, wall.vertexBuffer);
      // var coord = gl.getAttribLocation(program, "coordinates");
      // gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(coord);
      // gl.drawArrays(gl.TRIANGLE_FAN, 0, wall.values.vertices.length/3);

      //particles
      // gl.bindBuffer(gl.ARRAY_BUFFER, particle_buffer);
      // var coord = gl.getAttribLocation(program, "coordinates");
      // gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(coord);
      //particles
      // for (let i = 0; i < particle.particleCount; i++){
      //   particle.particleList[i].update(now);
      //   particle.particleList[i].checkCollision(mouseyNDC, mousexNDC);
      //   gl.uniformMatrix4fv(u_model, false, particle.particleList[i].translation.array);
      //   gl.uniform4fv(u_color, particle.particleList[i].color);
      //   gl.drawArrays(gl.POINTS, i, 1);
      // }

      cube.associateBuffers();
      cube.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 24);

      requestAnimationFrame(render)
    }
  </script>
</body>
</html>
