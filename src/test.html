<!DOCTYPE html>
<html>
<!-- UTIL FILES FOR SYSTEM FUNCTION -->
<script type="text/javascript" src="../utils/webgl-utils.js"></script>
<script type="text/javascript" src="../utils/initShaders.js"></script>
<script type="text/javascript" src="../math/MV.js"></script>
<script type="text/javascript" src="plane.js"></script>
<script type="text/javascript" src="mouseControls.js"></script>


<head>
<title>Project LINK</title>
</head>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec3 coordinates;
attribute vec4 u_color;
uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;
varying vec4 v_color;

void main(){
vec4 position = vec4(u_projection * u_view * u_model * vec4(coordinates, 1.0));
gl_Position = position;
gl_PointSize = 10.0;
v_color = u_color;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
varying vec4 v_color;
void main(){
    gl_FragColor = v_color;
}
</script>

<body bgcolor="#afafaf">
  <div>
    <canvas id="gl-canvas" width="1024" height="784">
      Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
  </div>

  <script>
    var gl;
    var u_color;
    var ground;
    var u_model, u_view, u_projection;
    var canvas;
    var now;
    var vertex_buffer, color_buffer, line_buffer, line_color_buffer;
    var program;
    var dragging;
    var oldx, x, oldy, y;
    var front = vec3(0.0, 0.0, -1.0);
    var box;
    var prevX, prevY = 0;
    var pitch = 0.0;
    var yaw = 0.0;
    /*================Creating a canvas=================*/
    window.onload = function init(event){
      canvas = document.getElementById("gl-canvas"); //get the canvas instance
      gl = WebGLUtils.setupWebGL(canvas); //setup the instance
      if ( !gl ) { alert( "WebGL isn't available" ); }


      box = gl.canvas.getBoundingClientRect();
      gl.viewport( 0, 0, canvas.width, canvas.height ); //set the instance view
      gl.clearColor( 1.0, 1.0, 1.0, 1.0 ); //set clear color of canvas
      gl.enable(gl.DEPTH_TEST);

      /*==========Defining and storing the geometry=======*/
      ground = new Plane(3.0, 0.0);

      program = initShaders(gl, "vertex-shader", "fragment-shader");
      gl.useProgram(program);


      canvas.onmousedown = function(event) {  //Mouse is pressed
           x = event.clientX;
           y = event.clientY;
           var rect = event.target.getBoundingClientRect();
           if (rect.left <= x && rect.right > x &&
            rect.top <= y && rect.bottom > y) {
            lastX = x;
            lastY = y;
            dragging = true;
        }
         };

         canvas.onmouseup = function(event){ //Mouse is released
           dragging = false;
         }

         canvas.onmousemove = function(event) { //Mouse is moved
           if(dragging) {
             x = event.clientX;
             y = event.clientY;
             let dx = (x - lastX)/canvas.width;
             let dy = (y - lastY)/canvas.height;
             let scale = 80;
             yaw += scale * dx
             yaw = Math.max(Math.min(yaw, 90), -90);
             pitch += scale * dy;
             pitch = Math.max(Math.min(pitch, 90), -90);
           }
           lastX = x;
           lastY = y;
         }


      //get uniform location for vertex shader
      u_model = gl.getUniformLocation(program, "u_model");
      u_projection = gl.getUniformLocation(program, "u_projection");
      u_view = gl.getUniformLocation(program, "u_view");

      // Create an empty buffer object to store the vertex buffer
      //Bind appropriate array buffer to it
      // Pass the vertex data to the buffer
      // Unbind the buffer
      vertex_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.vertices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      color_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.colors), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      line_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, line_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.grid.vertices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      line_color_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, line_color_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.grid.colors), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      /*======== Associating shaders to buffer objects ========*/
      // Bind vertex buffer object
      // Get the attribute location
      // Point an attribute to the currently bound VBO
      // Enable the attribute
      gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
      var coord = gl.getAttribLocation(program, "coordinates");
      gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      gl.bindBuffer(gl.ARRAY_BUFFER, line_buffer);
      var coord = gl.getAttribLocation(program, "coordinates");
      gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
      var coord = gl.getAttribLocation(program, "u_color");
      gl.vertexAttribPointer(coord, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      gl.bindBuffer(gl.ARRAY_BUFFER, line_color_buffer);
      var coord = gl.getAttribLocation(program, "u_color");
      gl.vertexAttribPointer(coord, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      /*============= Drawing the primitive ===============*/
      render()
    }

    function render(now, event){
      // Clear the canvas AND the depth buffer.
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // // Turn on culling. By default backfacing triangles
      // // will be culled.
      // gl.enable(gl.CULL_FACE);

      // // Enable the depth buffer
      gl.enable(gl.DEPTH_TEST);

      lookat = lookAt(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
      let yrotate = rotate(pitch, 1.0, 0.0, 0.0);
      let xrotate = rotate(yaw, 0.0, 1.0, 0.0);
      lookat = mult(lookat, yrotate);
      lookat = mult(lookat, xrotate);

      gl.uniformMatrix4fv(u_model, false, flatten(mat4()));
      gl.uniformMatrix4fv(u_projection, false, flatten(perspective(120, canvas.height/canvas.width, 0.1, 1000)));
      gl.uniformMatrix4fv(u_view, false, flatten(lookat));
      gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
      var coord = gl.getAttribLocation(program, "coordinates");
      gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
      var coord = gl.getAttribLocation(program, "u_color");
      gl.vertexAttribPointer(coord, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);
      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

      gl.bindBuffer(gl.ARRAY_BUFFER, line_buffer);
      var coord = gl.getAttribLocation(program, "coordinates");
      gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);

      gl.bindBuffer(gl.ARRAY_BUFFER, line_color_buffer);
      var coord = gl.getAttribLocation(program, "u_color");
      gl.vertexAttribPointer(coord, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(coord);
      gl.drawArrays(gl.LINES, 0, ground.grid.gridLines);

      requestAnimationFrame(render)
    }
  </script>
</body>
</html>
