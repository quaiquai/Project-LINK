<!DOCTYPE html>
<html>
<!-- UTIL FILES FOR SYSTEM FUNCTION -->
<script type="text/javascript" src="../utils/webgl-utils.js"></script>
<script type="text/javascript" src="../utils/initShaders.js"></script>
<script type="text/javascript" src="../math/MV.js"></script>
<script type="text/javascript" src="../math/Mat4.js"></script>
<script type="text/javascript" src="plane.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="primitives.js"></script>
<script type="text/javascript" src="particleStream.js"></script>
<script type="text/javascript" src="particle.js"></script>
<script type="text/javascript" src="lighting.js"></script>
<script type="text/javascript" src="shaders/FS_directionalLight.js"></script>
<script type="text/javascript" src="shaders/VS_directionalLight.js"></script>
<script type="text/javascript" src="shaders/FS_pointLight.js"></script>
<script type="text/javascript" src="shaders/VS_pointLight.js"></script>

<head>
<title>Project LINK</title>
</head>

<style>
.slider {
  -webkit-appearance: none;
  width: 25%;
  height: 15px;
  border-radius: 5px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  border-radius: 50%;
  background: #4CAF50;
  cursor: pointer;
}
</style>

<body bgcolor="#afafaf">
  <div>
    <canvas id="gl-canvas" width="1600" height="800">
      Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
  </div>
  <div class="slidecontainer">
    <input type="range" min="1" max="20" value="5" class="slider" id="speedValue">
    <label for="speedValue">Speed</label>
    <input type="range" min="1" max="100" value="5" class="slider" id="rhoDensity">
    <label for="rhoValue">rho</label>
  </div>

  <script>
    var gl;
    var u_color;
    var ground;
    var u_model, u_view, u_projection;
    var canvas;
    var now;
    var vertex_buffer, color_buffer, line_buffer, line_color_buffer;
    var program;
    var dragging;
    var oldx, x, oldy, y;
    var front = vec3(0.0, 0.0, -1.0);
    var box;
    var prevX, prevY = 0;
    var pitch = 0.0;
    var yaw = -90.0;
    var xpos = 0.0;
    var ypos = 1.0;
    var zpos = 1.0;
    var dx= 0, dy = 0;
    var forwardX = 0;
    var forwardZ = 0;
    var bobs = 0.2;
    var vBufferId, indexBuffer;
    var keyState = {};
    var cube, cubeLight, light;
    var wall, wall2, wall3, wall4, flat;
    var slider, sliderRho, mousexNDC, mouseyNDC;
    var at = vec3(0.0, 0.0, -1.0);
    var eye = vec3(0.0, 0.2, 1.0);
    var reverseLightDirectionLocation;
    var lightWorldPositionLocation;
    var viewPosition, shininessLocation, lightColorLocation, specularColorLocation;
    /*================Creating a canvas=================*/
    window.onload = function init(event){
      canvas = document.getElementById("gl-canvas"); //get the canvas instance
      slider = document.getElementById("speedValue");
      sliderRho = document.getElementById("rhoDensity");
      gl = WebGLUtils.setupWebGL(canvas); //setup the instance
      if ( !gl ) { alert( "WebGL isn't available" ); }

      box = gl.canvas.getBoundingClientRect();
      gl.viewport( 0, 0, canvas.width, canvas.height ); //set the instance view
      gl.clearColor( 0.5, 0.5, 0.5, 1.0 ); //set clear color of canvas
      gl.enable(gl.DEPTH_TEST);

      /*==========Defining and storing the geometry=======*/
      // ground = new Plane(100.0, 100.0, 0.0);
      // particle = new ParticleStream(0.0, 0.9, 10, 1000)
      camera = new Camera("fps")

      light = new Lighting("point");
      light.associateShaders();
      light.genUniforms();

      cube = new Cube(0.2);
      cube.genBuffers();
      cube.genUniforms();

      wall = new Wall([-1, 0, -1], [1, 1, -1], [0, 0, 1]);
      wall.genBuffers();
      wall.genUniforms();

      wall2 = new Wall([1, 0, -1], [1, 1, 1], [-1, 0, 0]);
      wall2.genBuffers();
      wall2.genUniforms();

      wall3 = new Wall([-1, 0, 1], [-1, 1, -1], [1, 0, 0]);
      wall3.genBuffers();
      wall3.genUniforms();

      wall4 = new Wall([1, 0, 1], [-1, 1, 1], [0, 0, -1]);
      wall4.genBuffers();
      wall4.genUniforms();

      flat = new Flat([-1, 0, 1], [1, 0, -1], 0, [0, 1, 0]);
      flat.genBuffers();
      flat.genUniforms();

      //get uniform location for vertex shader
      // u_model = gl.getUniformLocation(program, "u_model");
      u_projection = gl.getUniformLocation(program, "u_projection");
      u_view = gl.getUniformLocation(program, "u_view");
      // u_color = gl.getUniformLocation(program, "u_color");

      // Create an empty buffer object to store the vertex buffer
      //Bind appropriate array buffer to it
      // Pass the vertex data to the buffer
      // Unbind the buffer
      //ground
      // gl.bindBuffer(gl.ARRAY_BUFFER, ground.vertexBuffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ground.grid.vertices), gl.STATIC_DRAW);
      // gl.bindBuffer(gl.ARRAY_BUFFER, null);

      //particle
      // particle_buffer = gl.createBuffer();
      // gl.bindBuffer(gl.ARRAY_BUFFER, particle_buffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particle.particleStreamVerts), gl.STATIC_DRAW);
      // gl.bindBuffer(gl.ARRAY_BUFFER, null);

      window.onmousemove = function(event){
        var mousex = event.clientX;
        var mousey = event.clientY;
        mousexNDC = (mousex / canvas.clientWidth) * 2 - 1;
        mouseyNDC = (1 - (mousey / canvas.clientHeight)) * 2 - 1;
      }

      /*============= Drawing the primitive ===============*/
      now = 0;
      render()
    }

    function render(event){
      now += 0.01;
      // Clear the canvas AND the depth buffer.
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      tick();

      // // Turn on culling. By default backfacing triangles
      // // will be culled.
      // gl.enable(gl.CULL_FACE);

      // // Enable the depth buffer
      gl.enable(gl.DEPTH_TEST);
      lookat = lookAt(eye, vec3(eye[0] + at[0], eye[1] + (-at[1]), eye[2] + at[2]), vec3(0.0, 1.0, 0.0));

      //****************************************************************
      //for orbital
      // lookat = lookAt(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
      // let yrotate = rotate(yaw, 0.0, 1.0, 0.0);
      // let xrotate = rotate(pitch, 1.0, 0.0, 0.0);
      // lookat = mult(lookat, xrotate);
      // lookat = mult(lookat, yrotate);

      // gl.uniformMatrix4fv(u_model, false, flatten(mat4()));
      gl.uniformMatrix4fv(u_projection, false, flatten(perspective(90, canvas.width/canvas.height, 0.01, 1000)));
      gl.uniformMatrix4fv(u_view, false, flatten(lookat));

      light.setUniforms();

      /*======== Associating shaders to buffer objects ========*/
      // Bind vertex buffer object
      // Get the attribute location
      // Point an attribute to the currently bound VBO
      // Enable the attribute
      //ground
      // gl.bindBuffer(gl.ARRAY_BUFFER, ground.vertexBuffer);
      // var coord = gl.getAttribLocation(program, "coordinates");
      // gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(coord);
      // gl.drawArrays(gl.LINES, 0, ground.grid.gridLines);

      //particles
      // gl.bindBuffer(gl.ARRAY_BUFFER, particle_buffer);
      // var coord = gl.getAttribLocation(program, "coordinates");
      // gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(coord);
      //particles
      // for (let i = 0; i < particle.particleCount; i++){
      //   particle.particleList[i].update(now);
      //   particle.particleList[i].checkCollision(mouseyNDC, mousexNDC);
      //   gl.uniformMatrix4fv(u_model, false, particle.particleList[i].translation.array);
      //   gl.uniform4fv(u_color, particle.particleList[i].color);
      //   gl.drawArrays(gl.POINTS, i, 1);
      // }

      cube.associateBuffers();
      cube.model = mult(cube.model, rotate(0.5, 0.0, 1.0, 0.0));
      cube.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 24);

      wall.associateBuffers();
      wall.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      wall2.associateBuffers();
      wall2.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      wall3.associateBuffers();
      wall3.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      wall4.associateBuffers();
      wall4.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      flat.associateBuffers();
      flat.setUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render)
    }
  </script>
</body>
</html>
